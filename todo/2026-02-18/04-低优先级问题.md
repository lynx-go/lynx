# ä½ä¼˜å…ˆçº§é—®é¢˜

è¿™äº›æ˜¯ä»£ç å®Œå–„æ€§æ”¹è¿›ï¼Œä¸å½±å“æ ¸å¿ƒåŠŸèƒ½ï¼Œä½†è§£å†³åå¯æé«˜ä»£ç è´¨é‡ã€‚

---

## é—®é¢˜ 1: RequestLogger mutex è¢«æ³¨é‡Š

### ä½ç½®
- `server/http/requestlog.go:17,44-47`

### é—®é¢˜æè¿°

`sync.Mutex` ç›¸å…³ä»£ç è¢«æ³¨é‡Šæ‰ï¼Œçœ‹èµ·æ¥æ˜¯ä¸å®Œæ•´çš„é‡æ„ï¼š

```go
// server/http/requestlog.go:14-22
type RequestLogger struct {
    onErr func(error)

    //mu     sync.Mutex  // âŒ è¢«æ³¨é‡Š
    logger *slog.Logger
    //w   io.Writer     // âŒ è¢«æ³¨é‡Š
    //buf bytes.Buffer   // âŒ è¢«æ³¨é‡Š
    //enc *json.Encoder  // âŒ è¢«æ³¨é‡Š
}

// server/http/requestlog.go:43-47
func (l *RequestLogger) log(ent *requestlog.Entry) error {
    //defer l.mu.Unlock()  // âŒ è¢«æ³¨é‡Š
    //l.mu.Lock()          // âŒ è¢«æ³¨é‡Š
    // ...
}
```

### å½±å“

1. **ä»£ç ä¸å®Œæ•´** - æ³¨é‡Šçš„ä»£ç è®©äººå›°æƒ‘
2. **æ½œåœ¨çš„å¹¶å‘é—®é¢˜** - å¦‚æœå°†æ¥éœ€è¦å¹¶å‘å†™å…¥
3. **æ–‡æ¡£æ„ä¹‰ä¸æ˜** - ä¸æ¸…æ¥šæ˜¯å¦éœ€è¦è¿™äº›å­—æ®µ

### ä¿®å¤å»ºè®®

```go
// æ–¹æ¡ˆ 1: å®Œå…¨ç§»é™¤æ³¨é‡Šä»£ç  (æ¨è)
type RequestLogger struct {
    onErr  func(error)
    logger *slog.Logger
}

func (l *RequestLogger) log(ent *requestlog.Entry) error {
    // slog.Logger æœ¬èº«æ˜¯å¹¶å‘å®‰å…¨çš„ï¼Œä¸éœ€è¦é¢å¤–é”
    var r struct { ... }
    // ... æ—¥å¿—é€»è¾‘
    l.logger.Debug("requestlog", "request", r)
    return nil
}

// æ–¹æ¡ˆ 2: å¦‚æœéœ€è¦æ¢å¤å¹¶å‘ä¿æŠ¤
type RequestLogger struct {
    mu     sync.Mutex
    onErr  func(error)
    logger *slog.Logger
}

func (l *RequestLogger) log(ent *requestlog.Entry) error {
    l.mu.Lock()
    defer l.mu.Unlock()
    // ... æ—¥å¿—é€»è¾‘
}
```

---

## é—®é¢˜ 2: Listener æœªæ˜¾å¼ç®¡ç†

### ä½ç½®
- `server/grpc/server.go:112-124`

### é—®é¢˜æè¿°

`net.Listen` åˆ›å»ºçš„ listener æ²¡æœ‰æ˜¾å¼ç®¡ç†ï¼Œä¾èµ– `GracefulStop` é—´æ¥å…³é—­ï¼š

```go
// server/grpc/server.go:109-125
func (s *Server) Start(ctx context.Context) error {
    log.InfoContext(ctx, "starting gRPC server, listening on "+s.o.Addr)

    lis, err := net.Listen("tcp", s.o.Addr)  // âŒ listener æœªä¿å­˜
    if err != nil {
        return err
    }

    s.health.SetServingStatus("grpc", grpc_health_v1.HealthCheckResponse_SERVING)
    reflection.Register(s.server)
    s.running.Store(true)
    return s.server.Serve(lis)
}
```

### å½±å“

1. **èµ„æºç®¡ç†ä¸æ˜ç¡®** - listener ç”Ÿå‘½å‘¨æœŸä¸é€æ˜
2. **éš¾ä»¥è°ƒè¯•** - æ— æ³•æŸ¥çœ‹ç›‘å¬çŠ¶æ€
3. **æ½œåœ¨æ³„æ¼** - å¦‚æœ Serve å¼‚å¸¸é€€å‡º

### ä¿®å¤å»ºè®®

```go
type Server struct {
    server   *grpc.Server
    listener net.Listener  // æ·»åŠ  listener å­—æ®µ
    logger   *slog.Logger
    o        Options
    health   *health.Server
    running  atomic.Bool
}

func (s *Server) Start(ctx context.Context) error {
    log.InfoContext(ctx, "starting gRPC server, listening on "+s.o.Addr)

    lis, err := net.Listen("tcp", s.o.Addr)
    if err != nil {
        return fmt.Errorf("failed to listen on %s: %w", s.o.Addr, err)
    }
    s.listener = lis  // ä¿å­˜ listener

    s.health.SetServingStatus("grpc", grpc_health_v1.HealthCheckResponse_SERVING)
    reflection.Register(s.server)
    s.running.Store(true)
    return s.server.Serve(lis)
}

func (s *Server) Stop(ctx context.Context) {
    log.InfoContext(ctx, "stopping gRPC server")

    if s.health != nil {
        s.health.SetServingStatus("grpc", grpc_health_v1.HealthCheckResponse_NOT_SERVING)
    }
    s.running.Store(false)

    // å…ˆå…³é—­ listenerï¼Œåœæ­¢æ¥å—æ–°è¿æ¥
    if s.listener != nil {
        s.listener.Close()
    }

    // ç„¶åä¼˜é›…å…³é—­æœåŠ¡å™¨
    if s.server != nil {
        // ... å¸¦è¶…æ—¶çš„ GracefulStop
    }
}
```

---

## é—®é¢˜ 3: ç¼ºå°‘å•å…ƒæµ‹è¯•

### ä½ç½®
- æ•´ä¸ªä»£ç åº“

### é—®é¢˜æè¿°

å½“å‰ä»£ç åº“æ²¡æœ‰ä»»ä½•å•å…ƒæµ‹è¯•æ–‡ä»¶ (`*_test.go`)ã€‚

### å½±å“

1. **å›å½’é£é™©** - é‡æ„å¯èƒ½å¼•å…¥ bug
2. **ä¿¡å¿ƒä¸è¶³** - æ— æ³•éªŒè¯ä¿®å¤æ­£ç¡®æ€§
3. **æ–‡æ¡£ç¼ºå¤±** - æµ‹è¯•æ˜¯æœ€å¥½çš„ä½¿ç”¨æ–‡æ¡£

### ä¿®å¤å»ºè®®

å‚è§ [06-æµ‹è¯•å»ºè®®.md](./06-æµ‹è¯•å»ºè®®.md)ã€‚

---

## é—®é¢˜ 4: é”™è¯¯å˜é‡æœªå¯¼å‡º

### ä½ç½®
- å¤šä¸ªæ–‡ä»¶

### é—®é¢˜æè¿°

ä¸€äº›é”™è¯¯å€¼ä½œä¸ºå±€éƒ¨å˜é‡æˆ–æœªå¯¼å‡ºå˜é‡ï¼Œæ— æ³•è¢«è°ƒç”¨è€…æ¯”è¾ƒï¼š

```go
// å½“å‰å®ç°æ²¡æœ‰å®šä¹‰å¯æ¯”è¾ƒçš„é”™è¯¯ç±»å‹
// ä¾‹å¦‚ï¼šErrNotInitialized, ErrTimeout ç­‰
```

### ä¿®å¤å»ºè®®

```go
// å®šä¹‰å¯å¯¼å‡ºçš„é”™è¯¯å˜é‡
var (
    ErrNotInitialized = errors.New("component not initialized")
    ErrTimeout        = errors.New("operation timeout")
    ErrCancelled      = errors.New("operation cancelled")
)

// æˆ–ä½¿ç”¨ errors.New åˆ›å»ºå“¨å…µé”™è¯¯
// errors.go
package lynx

import "errors"

var (
    ErrConfigNotFound = errors.New("config not found")
    ErrComponentFailed = errors.New("component failed")
)
```

---

## é—®é¢˜ 5: ç¼ºå°‘æ–‡æ¡£æ³¨é‡Š

### ä½ç½®
- å¤šä¸ªæ–‡ä»¶

### é—®é¢˜æè¿°

éƒ¨åˆ†å…¬å¼€ API ç¼ºå°‘ GoDoc æ³¨é‡Šï¼š

```go
// lynx.go - éƒ¨åˆ†å‡½æ•°æœ‰æ³¨é‡Šï¼Œéƒ¨åˆ†æ²¡æœ‰

// âŒ ç¼ºå°‘æ³¨é‡Š
func IDFromContext(ctx context.Context) string {
    return ctx.Value(keyId).(string)
}

// âŒ ç¼ºå°‘æ³¨é‡Š
func (app *lynx) Hooks(hooks ...HookOption) error {
    // ...
}
```

### ä¿®å¤å»ºè®®

```go
// IDFromContext returns the instance ID from the context.
// If the ID is not set, it returns an empty string.
func IDFromContext(ctx context.Context) string {
    if v := ctx.Value(keyId); v != nil {
        if s, ok := v.(string); ok {
            return s
        }
    }
    return ""
}

// Hooks registers lifecycle hooks and components with the application.
// Multiple HookOption values can be passed to register multiple hooks
// or components in a single call.
//
// Example:
//
//  app.Hooks(
//      lynx.OnStart(startFunc),
//      lynx.OnStop(stopFunc),
//      lynx.Components(httpServer, grpcServer),
//  )
func (app *lynx) Hooks(hooks ...HookOption) error {
    // ...
}
```

---

## é—®é¢˜ 6: Options ç»“æ„ä½“å­—æ®µç¼ºå°‘éªŒè¯

### ä½ç½®
- `options.go`, å¤šä¸ªç»„ä»¶çš„ Options

### é—®é¢˜æè¿°

Options ç»“æ„ä½“æ²¡æœ‰éªŒè¯é€»è¾‘ï¼Œå¯èƒ½å¯¼è‡´æ— æ•ˆé…ç½®ï¼š

```go
// options.go - ç¼ºå°‘éªŒè¯
type Options struct {
    Name         string
    ID           string
    Version      string
    CloseTimeout time.Duration
    // ...
}

func (o *Options) EnsureDefaults() {
    // åªè®¾ç½®é»˜è®¤å€¼ï¼Œæ²¡æœ‰éªŒè¯
    if o.Name == "" {
        o.Name = "lynx"
    }
    // ...
}
```

### ä¿®å¤å»ºè®®

```go
type Options struct {
    Name         string        `validate:"required,min=1,max=63"`
    ID           string        `validate:"omitempty,hostname"`
    Version      string        `validate:"omitempty,semver"`
    CloseTimeout time.Duration `validate:"omitempty,min=1s,max=5m"`
}

func (o *Options) Validate() error {
    if o.Name == "" {
        return errors.New("name is required")
    }
    if len(o.Name) > 63 {
        return errors.New("name must be at most 63 characters")
    }
    if o.CloseTimeout < 0 {
        return errors.New("close timeout must be positive")
    }
    if o.CloseTimeout > 5*time.Minute {
        return errors.New("close timeout must be at most 5 minutes")
    }
    return nil
}

func (o *Options) EnsureDefaults() error {
    if o.Name == "" {
        o.Name = "lynx"
    }
    if o.ID == "" {
        hostname, _ := os.Hostname()
        o.ID = hostname
    }
    if o.CloseTimeout == 0 {
        o.CloseTimeout = 30 * time.Second
    }
    return o.Validate()
}
```

---

## é—®é¢˜ 7: ç¡¬ç¼–ç çš„é­”æ³•å€¼

### ä½ç½®
- å¤šä¸ªæ–‡ä»¶

### é—®é¢˜æè¿°

ä»£ç ä¸­å­˜åœ¨ç¡¬ç¼–ç çš„é­”æ³•å€¼ï¼š

```go
// lynx.go:140-145
func DefaultSetFlagsFunc(f *pflag.FlagSet) {
    f.StringP("config", "c", "", "config file path")
    f.String("config-type", "yaml", "config file type, default yaml")  // âŒ ç¡¬ç¼–ç  "yaml"
    // ...
}

// server/http/server.go:61
options := Options{
    Addr:    ":8080",  // âŒ ç¡¬ç¼–ç ç«¯å£
    Timeout: time.Second * 60,  // âŒ ç¡¬ç¼–ç è¶…æ—¶
}

// server/grpc/server.go:54
options := Options{
    Addr:    ":9090",  // âŒ ç¡¬ç¼–ç ç«¯å£
    Timeout: time.Second * 60,  // âŒ ç¡¬ç¼–ç è¶…æ—¶
}
```

### ä¿®å¤å»ºè®®

```go
// å®šä¹‰å¸¸é‡
const (
    DefaultHTTPAddr    = ":8080"
    DefaultGRPCAddr    = ":9090"
    DefaultTimeout     = 60 * time.Second
    DefaultConfigType  = "yaml"
    DefaultCloseTimeout = 30 * time.Second
)

// ä½¿ç”¨å¸¸é‡
func NewServer(handler http.Handler, opts ...Option) *Server {
    options := Options{
        Addr:    DefaultHTTPAddr,
        Timeout: DefaultTimeout,
        Logger:  slog.Default(),
    }
    // ...
}
```

---

## é—®é¢˜æ±‡æ€»è¡¨

| é—®é¢˜ | ä¸¥é‡ç¨‹åº¦ | å½±å“ | ä¿®å¤éš¾åº¦ | çŠ¶æ€ |
|------|---------|------|---------|------|
| RequestLogger mutex æ³¨é‡Š | ğŸŸ¢ ä½ | ä»£ç ä¸æ•´æ´ | ä½ | âœ… å·²ä¿®å¤ |
| Listener æœªç®¡ç† | ğŸŸ¢ ä½ | èµ„æºç®¡ç†ä¸æ˜ç¡® | ä½ | âœ… å·²ä¿®å¤ |
| ç¼ºå°‘å•å…ƒæµ‹è¯• | ğŸŸ¢ ä½ | å›å½’é£é™© | é«˜ | â¸ï¸ é•¿æœŸä»»åŠ¡ |
| é”™è¯¯å˜é‡æœªå¯¼å‡º | ğŸŸ¢ ä½ | æ— æ³•æ¯”è¾ƒé”™è¯¯ | ä½ | âœ… å·²ä¿®å¤ |
| ç¼ºå°‘æ–‡æ¡£æ³¨é‡Š | ğŸŸ¢ ä½ | æ–‡æ¡£ä¸å®Œå–„ | ä¸­ | âœ… å·²ä¿®å¤ |
| Options ç¼ºå°‘éªŒè¯ | ğŸŸ¢ ä½ | å¯èƒ½æ— æ•ˆé…ç½® | ä½ | â¸ï¸ å¾…å®š |
| ç¡¬ç¼–ç é­”æ³•å€¼ | ğŸŸ¢ ä½ | ç»´æŠ¤å›°éš¾ | ä½ | âœ… å·²ä¿®å¤ |

---

## ä¿®å¤ä¼˜å…ˆçº§

è¿™äº›æ˜¯ä½ä¼˜å…ˆçº§çš„æ”¹è¿›ï¼Œå¯ä»¥åœ¨æœ‰æ—¶é—´æ—¶é€æ­¥å®Œå–„ï¼š

1. **å¿«é€Ÿä¿®å¤** (1-2 å°æ—¶) âœ… å·²å®Œæˆ
   - ç§»é™¤æ³¨é‡Šä»£ç  âœ…
   - å®šä¹‰å¸¸é‡æ›¿æ¢é­”æ³•å€¼ âœ…
   - æ·»åŠ é”™è¯¯å˜é‡ âœ…

2. **ä¸­ç­‰æŠ•å…¥** (åŠå¤©)
   - æ·»åŠ æ–‡æ¡£æ³¨é‡Š âœ…
   - æ·»åŠ  Options éªŒè¯ â¸ï¸
   - ç®¡ç† Listener ç”Ÿå‘½å‘¨æœŸ âœ…

3. **é•¿æœŸæŠ•å…¥** (æŒç»­)
   - ç¼–å†™å•å…ƒæµ‹è¯• â¸ï¸
   - å®Œå–„æµ‹è¯•è¦†ç›–ç‡ â¸ï¸
