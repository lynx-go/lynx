# 中优先级问题

这些问题可能导致资源泄漏、配置不灵活或功能不完整，建议在短期迭代中修复。

---

## 问题 1: 关闭流程竞态条件

### 位置
- `lynx.go:266-277`

### 问题描述

OnStop hooks 与组件 Stop 在 `run.Group` 中并行执行，可能导致资源清理顺序问题：

```go
// lynx.go:239-278
func (app *lynx) Run() error {
    // OnStart hooks actor
    app.runG.Add(func() error {
        for _, fn := range app.hooks.onStarts {
            if err := fn(app.ctx); err != nil {
                return err
            }
        }
        select {
        case <-app.ctx.Done():
            return nil
        }
    }, func(err error) {
        app.Close()
    })

    // Signal handler actor
    app.runG.Add(func() error {
        exitCh := make(chan os.Signal, 1)
        signal.Notify(exitCh, app.o.ExitSignals...)
        select {
        case <-app.ctx.Done():
            return nil
        case <-exitCh:
            return nil
        }
    }, func(err error) {
        // ❌ OnStop hooks 和组件 Stop 并行执行
        app.Logger().Info("shutting down")
        ctx, cancelCtx := context.WithTimeout(context.TODO(), closeTimeout)
        defer cancelCtx()
        app.Logger().Info("run on-stop hooks")
        for _, fn := range app.hooks.onStops {
            fn := fn
            if err := fn(ctx); err != nil {
                app.logger.ErrorContext(app.ctx, "on-stop hook called error", "error", err)
            }
        }
    })
    return app.runG.Run()
}
```

### 影响

1. **清理顺序不确定** - OnStop hook 可能与组件 Stop 同时执行
2. **依赖关系难保证** - 如果 hook 依赖组件状态，可能失败
3. **难以调试** - 关闭时的错误难以复现

### 修复建议

实现有序的关闭流程：

```go
// 建议的关闭顺序：
// 1. 标记为 NOT_SERVING (停止接收新请求)
// 2. 执行 OnStop hooks (清理业务资源)
// 3. 停止组件 (run.Group 自动处理)
// 4. 释放基础资源

func (app *lynx) Run() error {
    // ... 启动逻辑

    // 修改 signal handler 的 interrupt 函数
    app.runG.Add(signalActor, func(err error) {
        app.Logger().Info("shutting down")
        ctx, cancelCtx := context.WithTimeout(context.Background(), app.o.CloseTimeout)
        defer cancelCtx()

        // 1. 先取消主 context，让组件开始停止
        app.cancelCtx()

        // 2. 执行 OnStop hooks
        app.Logger().Info("run on-stop hooks")
        for _, fn := range app.hooks.onStops {
            fn := fn
            if err := fn(ctx); err != nil {
                app.logger.ErrorContext(ctx, "on-stop hook error", "error", err)
                // 考虑是否应该中断
            }
        }
        // 3. run.Group 会自动停止所有组件
    })
    return app.runG.Run()
}
```

---

## 问题 2: CLI.Run 直接 Panic

### 位置
- `cli.go:22-26`

### 问题描述

`CLI.Run()` 方法在错误时直接 panic，不够优雅：

```go
// cli.go:22-26
func (app *CLI) Run() {
    if err := app.RunE(); err != nil {
        panic(err)  // ❌ 直接 panic
    }
}
```

### 影响

1. **不优雅的退出** - panic 会打印堆栈，不适合 CLI 应用
2. **main 函数复杂化** - 需要 recover 或使用 RunE
3. **退出码不正确** - panic 默认退出码 2，而非 1

### 修复建议

```go
func (app *CLI) Run() {
    if err := app.RunE(); err != nil {
        // 方案 1: 打印错误并退出
        fmt.Fprintf(os.Stderr, "Error: %v\n", err)
        os.Exit(1)

        // 方案 2: 如果需要堆栈，使用更友好的方式
        // if debug {
        //     fmt.Fprintf(os.Stderr, "Error: %+v\n", err)  // pkg/errors 格式
        // } else {
        //     fmt.Fprintf(os.Stderr, "Error: %v\n", err)
        // }
        // os.Exit(1)
    }
}
```

---

## 问题 3: 健康检查过于简单

### 位置
- `contrib/schedule/scheduler.go:25-27`

### 问题描述

Scheduler 的 `CheckHealth` 总是返回 nil，无法反映实际状态：

```go
// schedule/scheduler.go:25-27
func (s *Scheduler) CheckHealth() error {
    return nil  // ❌ 总是健康，无法检测问题
}
```

### 影响

1. **虚假健康** - 即使调度器崩溃也显示健康
2. **监控失效** - 无法发现定时任务问题
3. **K8s 问题** - 可能导致流量路由到故障实例

### 修复建议

```go
func (s *Scheduler) CheckHealth() error {
    // 检查 cron 实例是否存在
    if s.cron == nil {
        return errors.New("scheduler not initialized")
    }

    // 检查是否有正在运行的任务 (可选)
    // 可以通过 sync/atomic 记录最近执行状态

    return nil
}

// 更完善的实现
type Scheduler struct {
    options     *Options
    tasks       []Task
    cron        *cron.Cron
    app         lynx.Lynx
    lastRunTime atomic.Int64  // 记录最后一次任务运行时间
}

func (s *Scheduler) CheckHealth() error {
    if s.cron == nil {
        return errors.New("scheduler not initialized")
    }

    // 如果配置了健康检查超时，检查最近是否有任务运行
    // 这对于周期性任务很有用
    if s.options.HealthCheckTimeout > 0 {
        lastRun := time.Unix(s.lastRunTime.Load(), 0)
        if time.Since(lastRun) > s.options.HealthCheckTimeout {
            return fmt.Errorf("no task executed in last %v", s.options.HealthCheckTimeout)
        }
    }

    return nil
}
```

---

## 问题 4: 配置硬编码

### 位置
- `command.go:33-44`

### 问题描述

Command 组件的重试次数和退避策略硬编码：

```go
// command.go:33-44
func (cmd *command) Start(ctx context.Context) error {
    checkers := cmd.lynx.HealthCheckFunc()()
    if _, err := backoff.Retry[any](ctx, func() (any, error) {
        for _, checker := range checkers {
            if err := checker.CheckHealth(); err != nil {
                log.WarnContext(ctx, "waiting for dependent component ready", "error", err)
                return nil, err
            }
        }
        return nil, nil
    }, backoff.WithMaxTries(10), backoff.WithBackOff(backoff.NewExponentialBackOff())); err != nil {
        // ❌ 硬编码: MaxTries(10), ExponentialBackOff()
        return errors.Wrap(err, "failed to start components")
    }
    return cmd.fn(ctx)
}
```

### 影响

1. **不灵活** - 无法根据环境调整重试策略
2. **难以测试** - 无法注入 mock 重试逻辑
3. **生产风险** - 可能需要更长的等待时间

### 修复建议

```go
type CommandOptions struct {
    MaxTries       int
    InitialBackoff time.Duration
    MaxBackoff     time.Duration
}

type CommandOption func(*CommandOptions)

func WithMaxTries(n int) CommandOption {
    return func(o *CommandOptions) { o.MaxTries = n }
}

func WithBackoff(initial, max time.Duration) CommandOption {
    return func(o *CommandOptions) {
        o.InitialBackoff = initial
        o.MaxBackoff = max
    }
}

func NewCommand(fn CommandFunc, opts ...CommandOption) Component {
    options := &CommandOptions{
        MaxTries:       10,
        InitialBackoff: 100 * time.Millisecond,
        MaxBackoff:     30 * time.Second,
    }
    for _, opt := range opts {
        opt(options)
    }
    return &command{fn: fn, options: options}
}

func (cmd *command) Start(ctx context.Context) error {
    checkers := cmd.lynx.HealthCheckFunc()()

    backoffCfg := backoff.NewExponentialBackOff()
    backoffCfg.InitialInterval = cmd.options.InitialBackoff
    backoffCfg.MaxInterval = cmd.options.MaxBackoff

    if _, err := backoff.Retry[any](ctx, func() (any, error) {
        for _, checker := range checkers {
            if err := checker.CheckHealth(); err != nil {
                log.WarnContext(ctx, "waiting for dependent component ready", "error", err)
                return nil, err
            }
        }
        return nil, nil
    }, backoff.WithMaxTries(cmd.options.MaxTries), backoff.WithBackOff(backoffCfg)); err != nil {
        return errors.Wrap(err, "failed to start components")
    }
    return cmd.fn(ctx)
}
```

---

## 问题 5: 资源未释放

### 位置
- `contrib/zap/logger.go`

### 问题描述

`zap.Logger` 有 `Sync()` 方法用于刷新缓冲区，但当前实现未封装：

```go
// contrib/zap/logger.go
// ❌ 没有提供 Sync/Close 方法
```

### 影响

1. **日志丢失** - 程序崩溃时可能丢失缓冲区中的日志
2. **资源泄漏** - 文件句柄可能未正确关闭
3. **不完整日志** - 无法保证日志完整性

### 修复建议

```go
// 添加 Sync 封装
func Sync(logger *slog.Logger) error {
    // 需要访问底层的 zap.Logger
    // 可以通过自定义 handler 暴露
    return nil
}

// 或创建可关闭的 logger wrapper
type ClosableLogger struct {
    *slog.Logger
    zapLogger *zap.Logger
}

func (l *ClosableLogger) Close() error {
    return l.zapLogger.Sync()
}

// 使用方式
func NewClosableLogger(app lynx.Lynx) (*ClosableLogger, error) {
    zapLogger, err := NewZapLogger(getLevel(app))
    if err != nil {
        return nil, err
    }
    slogger, err := NewSLogger(zapLogger, getLevel(app))
    if err != nil {
        return nil, err
    }
    return &ClosableLogger{
        Logger:    slogger,
        zapLogger: zapLogger,
    }, nil
}
```

---

## 问题 6: OnStop 错误处理不足

### 位置
- `lynx.go:273-275`

### 问题描述

OnStop hook 错误只记录不中断，可能导致状态不一致：

```go
// lynx.go:273-275
for _, fn := range app.hooks.onStops {
    fn := fn
    if err := fn(ctx); err != nil {
        app.logger.ErrorContext(app.ctx, "on-stop hook called error", "error", err)
        // ❌ 只记录，继续执行下一个
    }
}
```

### 影响

1. **状态不一致** - 部分清理失败，部分成功
2. **错误丢失** - 调用者无法知道关闭是否完全成功
3. **难以诊断** - 多个 hook 失败时，只看到日志

### 修复建议

```go
// 方案 1: 收集所有错误
type ShutdownErrors struct {
    errors []error
}

func (e *ShutdownErrors) Add(err error) {
    e.errors = append(e.errors, err)
}

func (e *ShutdownErrors) Error() string {
    if len(e.errors) == 0 {
        return ""
    }
    var msgs []string
    for _, err := range e.errors {
        msgs = append(msgs, err.Error())
    }
    return strings.Join(msgs, "; ")
}

func (e *ShutdownErrors) HasErrors() bool {
    return len(e.errors) > 0
}

// 方案 2: 使用 multierr (推荐)
import "go.uber.org/multierr"

func (app *lynx) shutdown(ctx context.Context) error {
    var errs error
    for _, fn := range app.hooks.onStops {
        fn := fn
        if err := fn(ctx); err != nil {
            app.logger.ErrorContext(ctx, "on-stop hook error", "error", err)
            errs = multierr.Append(errs, err)
        }
    }
    return errs
}

// 方案 3: 支持失败快速中断选项
type OnStopOption struct {
    FailFast bool // 遇到错误立即停止
}
```

---

## 问题汇总表

| 问题 | 严重程度 | 影响 | 修复难度 | 状态 |
|------|---------|------|---------|------|
| 关闭流程竞态 | 🟠 中 | 资源清理顺序不确定 | 中 | ✅ 已修复 |
| CLI.Run panic | 🟠 中 | 不优雅的退出方式 | 低 | ✅ 已修复 |
| 健康检查简单 | 🟠 中 | 无法检测实际问题 | 低 | ✅ 已修复 |
| 配置硬编码 | 🟠 中 | 不灵活 | 低 | ✅ 已修复 |
| 资源未释放 | 🟠 中 | 日志丢失 | 低 | ✅ 已修复 |
| OnStop 错误处理 | 🟠 中 | 状态不一致 | 低 | ✅ 已修复 |

---

## 修复优先级

1. **Phase 2 - 短期修复** ✅ 已完成
   - CLI.Run panic → 优雅退出 ✅
   - 健康检查简单 → 增强检查 ✅
   - 配置硬编码 → 可配置选项 ✅

2. **Phase 3 - 中期修复** ✅ 已完成
   - 关闭流程竞态 → 有序关闭 ✅
   - 资源未释放 → 添加 Sync/Close ✅
   - OnStop 错误处理 → 错误聚合 ✅
