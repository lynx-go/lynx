# 优化代码示例

本文档提供具体可用的代码修复示例，可直接应用到代码库中。

---

## 1. Fatal 滥用修复

### 文件: `lynx.go`

**修改前:**
```go
func (app *lynx) initConfigure() error {
    if fn := app.o.SetFlagsFunc; fn != nil {
        fn(app.f)
        errors.Fatal(app.f.Parse(os.Args[1:]))
    }

    if fn := app.o.BindConfigFunc; fn != nil {
        if err := fn(app.f, app.c); err != nil {
            return err
        }

        errors.Fatal(app.c.ReadInConfig())
    }

    if app.o.SetFlagsFunc != nil {
        errors.Fatal(app.c.BindPFlags(app.f))
    }

    return nil
}

func newLynx(o *Options) Lynx {
    o.EnsureDefaults()
    app := &lynx{
        o:    o,
        c:    viper.New(),
        f:    pflag.CommandLine,
        runG: &run.Group{},
        hooks: &hooks{
            onStarts: []HookFunc{},
            onStops:  []HookFunc{},
        },
        logger: slog.Default(),
    }
    app.ctx, app.cancelCtx = context.WithCancel(context.Background())
    errors.Fatal(app.init())
    return app
}
```

**修改后:**
```go
func (app *lynx) initConfigure() error {
    if fn := app.o.SetFlagsFunc; fn != nil {
        fn(app.f)
        if err := app.f.Parse(os.Args[1:]); err != nil {
            return fmt.Errorf("failed to parse flags: %w", err)
        }
    }

    if fn := app.o.BindConfigFunc; fn != nil {
        if err := fn(app.f, app.c); err != nil {
            return fmt.Errorf("failed to bind config: %w", err)
        }

        if err := app.c.ReadInConfig(); err != nil {
            // 配置文件不存在可能是正常情况，取决于使用场景
            if _, ok := err.(viper.ConfigFileNotFoundError); !ok {
                return fmt.Errorf("failed to read config: %w", err)
            }
        }
    }

    if app.o.SetFlagsFunc != nil {
        if err := app.c.BindPFlags(app.f); err != nil {
            return fmt.Errorf("failed to bind pflags: %w", err)
        }
    }

    return nil
}

func newLynx(o *Options) (Lynx, error) {
    o.EnsureDefaults()
    app := &lynx{
        o:    o,
        c:    viper.New(),
        f:    pflag.CommandLine,
        runG: &run.Group{},
        hooks: &hooks{
            onStarts: []HookFunc{},
            onStops:  []HookFunc{},
        },
        logger: slog.Default(),
    }
    app.ctx, app.cancelCtx = context.WithCancel(context.Background())
    if err := app.init(); err != nil {
        return nil, err
    }
    return app, nil
}
```

**同步修改 `cli.go`:**
```go
func New(o *Options, setup SetupFunc) (*CLI, error) {
    app, err := newLynx(o)
    if err != nil {
        return nil, err
    }
    return &CLI{
        setup: setup,
        lynx:  app,
    }, nil
}
```

---

## 2. 并发安全修复

### 文件: `lynx.go`

**修改后:**
```go
import (
    // ... 现有 imports
    "sync"
)

type lynx struct {
    *hooks
    mu              sync.Mutex
    o               *Options
    f               *pflag.FlagSet
    c               *viper.Viper
    ctx             context.Context
    cancelCtx       context.CancelFunc
    runG            *run.Group
    logger          *slog.Logger
    healthCheckers  []health.Checker
}

func (app *lynx) Hooks(hooks ...HookOption) error {
    app.mu.Lock()
    defer app.mu.Unlock()

    options := &hookOptions{}
    for _, hook := range hooks {
        hook(options)
    }

    app.hooks.onStarts = append(app.hooks.onStarts, options.onStarts...)
    app.hooks.onStops = append(app.hooks.onStops, options.onStops...)

    if err := app.addComponentsLocked(options.components...); err != nil {
        return err
    }

    if err := app.addComponentBuildersLocked(options.componentBuilders...); err != nil {
        return err
    }
    return nil
}

func (app *lynx) addComponents(components ...Component) error {
    app.mu.Lock()
    defer app.mu.Unlock()
    return app.addComponentsLocked(components...)
}

func (app *lynx) addComponentsLocked(components ...Component) error {
    // 调用前必须持有 app.mu 锁
    for _, component := range components {
        ctx, cancel := context.WithCancel(context.Background())
        log.InfoContext(ctx, "initializing component", "component", component.Name())
        if err := component.Init(app); err != nil {
            cancel()
            return err
        }
        log.InfoContext(ctx, "initialized component", "component", component.Name())
        app.runG.Add(func() error {
            log.InfoContext(ctx, "starting component", "component", component.Name())
            return component.Start(ctx)
        }, func(err error) {
            log.InfoContext(ctx, "stopping component", "component", component.Name())
            component.Stop(ctx)
            cancel()
        })
        if hc, ok := component.(health.Checker); ok {
            app.healthCheckers = append(app.healthCheckers, hc)
        }
    }
    return nil
}

func (app *lynx) addComponentBuilders(builders ...ComponentBuilder) error {
    app.mu.Lock()
    defer app.mu.Unlock()
    return app.addComponentBuildersLocked(builders...)
}

func (app *lynx) addComponentBuildersLocked(builders ...ComponentBuilder) error {
    // 调用前必须持有 app.mu 锁
    for _, builder := range builders {
        build := builder.Build
        options := builder.Options()
        options.ensureDefaults()
        var components []Component
        for i := 0; i < options.Instances; i++ {
            comp := build()
            components = append(components, comp)
        }
        if err := app.addComponentsLocked(components...); err != nil {
            return err
        }
    }
    return nil
}
```

---

## 3. Context 值安全获取

### 文件: `lynx.go`

**修改后:**
```go
// IDFromContext returns the instance ID from the context.
// Returns an empty string if the ID is not set or has wrong type.
func IDFromContext(ctx context.Context) string {
    if v := ctx.Value(keyId); v != nil {
        if s, ok := v.(string); ok {
            return s
        }
    }
    return ""
}

// VersionFromContext returns the application version from the context.
// Returns an empty string if the version is not set or has wrong type.
func VersionFromContext(ctx context.Context) string {
    if v := ctx.Value(keyVersion); v != nil {
        if s, ok := v.(string); ok {
            return s
        }
    }
    return ""
}

// NameFromContext returns the application name from the context.
// Returns an empty string if the name is not set or has wrong type.
func NameFromContext(ctx context.Context) string {
    if v := ctx.Value(keyName); v != nil {
        if s, ok := v.(string); ok {
            return s
        }
    }
    return ""
}

// IDFromContextE returns the instance ID from the context with error.
// Returns an error if the ID is not set or has wrong type.
func IDFromContextE(ctx context.Context) (string, error) {
    if v := ctx.Value(keyId); v != nil {
        if s, ok := v.(string); ok {
            return s, nil
        }
    }
    return "", errors.New("id not found in context")
}
```

---

## 4. gRPC Server 超时和 GracefulStop 修复

### 文件: `server/grpc/server.go`

**修改后:**
```go
package grpc

import (
    "context"
    "fmt"
    "log/slog"
    "net"
    "sync/atomic"
    "time"

    "github.com/lynx-go/lynx"
    "github.com/lynx-go/lynx/server/grpc/interceptor"
    "github.com/lynx-go/x/log"
    "google.golang.org/grpc"
    "google.golang.org/grpc/health"
    "google.golang.org/grpc/health/grpc_health_v1"
    "google.golang.org/grpc/reflection"
)

const (
    DefaultAddr    = ":9090"
    DefaultTimeout = 60 * time.Second
)

type Options struct {
    Addr         string
    Timeout      time.Duration
    Logger       *slog.Logger
    Interceptors []grpc.UnaryServerInterceptor
}

type Option func(*Options)

func WithAddr(addr string) Option {
    return func(o *Options) { o.Addr = addr }
}

func WithTimeout(timeout time.Duration) Option {
    return func(o *Options) { o.Timeout = timeout }
}

func WithLogger(l *slog.Logger) Option {
    return func(o *Options) { o.Logger = l }
}

func WithInterceptors(interceptors ...grpc.UnaryServerInterceptor) Option {
    return func(o *Options) {
        o.Interceptors = append(o.Interceptors, interceptors...)
    }
}

func NewServer(opts ...Option) *Server {
    options := Options{
        Addr:    DefaultAddr,
        Timeout: DefaultTimeout,
        Logger:  slog.Default(),
    }
    for _, opt := range opts {
        opt(&options)
    }

    s := &Server{
        logger: options.Logger,
        o:      options,
    }
    interceptors := []grpc.UnaryServerInterceptor{
        interceptor.Logging(s.logger),
        interceptor.Recovery(),
    }
    interceptors = append(interceptors, options.Interceptors...)
    grpcOpts := []grpc.ServerOption{
        grpc.ChainUnaryInterceptor(interceptors...),
    }

    s.server = grpc.NewServer(grpcOpts...)

    // Register health check service
    s.health = health.NewServer()
    grpc_health_v1.RegisterHealthServer(s.server, s.health)
    return s
}

type Server struct {
    server   *grpc.Server
    listener net.Listener
    logger   *slog.Logger
    o        Options
    health   *health.Server
    running  atomic.Bool
}

func (s *Server) CheckHealth() error {
    if !s.running.Load() {
        return grpc.ErrServerStopped
    }
    return nil
}

func (s *Server) Name() string {
    return "grpc"
}

func (s *Server) Init(app lynx.Lynx) error {
    return nil
}

func (s *Server) Start(ctx context.Context) error {
    log.InfoContext(ctx, "starting gRPC server, listening on "+s.o.Addr)

    lis, err := net.Listen("tcp", s.o.Addr)
    if err != nil {
        return fmt.Errorf("failed to listen on %s: %w", s.o.Addr, err)
    }
    s.listener = lis

    // Set the server to healthy
    s.health.SetServingStatus("grpc", grpc_health_v1.HealthCheckResponse_SERVING)

    // Register reflection service
    reflection.Register(s.server)

    s.running.Store(true)
    return s.server.Serve(lis)
}

func (s *Server) Stop(ctx context.Context) {
    log.InfoContext(ctx, "stopping gRPC server")

    // 1. 先标记为不健康
    if s.health != nil {
        s.health.SetServingStatus("grpc", grpc_health_v1.HealthCheckResponse_NOT_SERVING)
    }
    s.running.Store(false)

    if s.server == nil {
        return
    }

    // 2. 尝试优雅关闭，支持 context 超时
    done := make(chan struct{})
    go func() {
        defer close(done)
        s.server.GracefulStop()
    }()

    select {
    case <-done:
        s.logger.Info("gRPC server stopped gracefully")
    case <-ctx.Done():
        s.logger.Warn("graceful stop timeout, forcing stop")
        s.server.Stop()
        <-done // 等待 GracefulStop goroutine 结束
    }
}

func (s *Server) GetServer() *grpc.Server {
    return s.server
}

var _ lynx.ServerLike = (*Server)(nil)
```

---

## 5. 错误聚合机制

### 新增文件: `errors.go`

```go
package lynx

import (
    "strings"
    "sync"
)

// ShutdownErrors collects multiple errors during shutdown.
// It is safe for concurrent use.
type ShutdownErrors struct {
    mu     sync.Mutex
    errors []error
}

// Add appends an error to the collection.
func (e *ShutdownErrors) Add(err error) {
    if err == nil {
        return
    }
    e.mu.Lock()
    defer e.mu.Unlock()
    e.errors = append(e.errors, err)
}

// Error returns a concatenated error message.
func (e *ShutdownErrors) Error() string {
    e.mu.Lock()
    defer e.mu.Unlock()
    if len(e.errors) == 0 {
        return ""
    }
    var msgs []string
    for _, err := range e.errors {
        msgs = append(msgs, err.Error())
    }
    return strings.Join(msgs, "; ")
}

// HasErrors returns true if any errors were collected.
func (e *ShutdownErrors) HasErrors() bool {
    e.mu.Lock()
    defer e.mu.Unlock()
    return len(e.errors) > 0
}

// Errors returns a copy of all collected errors.
func (e *ShutdownErrors) Errors() []error {
    e.mu.Lock()
    defer e.mu.Unlock()
    result := make([]error, len(e.errors))
    copy(result, e.errors)
    return result
}
```

### 修改 `lynx.go` Run 方法:

```go
func (app *lynx) Run() error {
    app.Logger().Info("starting")

    // OnStart hooks actor
    app.runG.Add(func() error {
        app.Logger().Info("run on-start hooks")
        for _, fn := range app.hooks.onStarts {
            if err := fn(app.ctx); err != nil {
                return err
            }
        }
        select {
        case <-app.ctx.Done():
            return nil
        }
    }, func(err error) {
        app.Close()
    })

    closeTimeout := app.o.CloseTimeout

    // Signal handler actor
    app.runG.Add(func() error {
        exitCh := make(chan os.Signal, 1)
        signal.Notify(exitCh, app.o.ExitSignals...)
        select {
        case <-app.ctx.Done():
            return nil
        case <-exitCh:
            return nil
        }
    }, func(err error) {
        app.Logger().Info("shutting down")
        ctx, cancelCtx := context.WithTimeout(context.Background(), closeTimeout)
        defer cancelCtx()

        // 执行 OnStop hooks，收集错误
        app.Logger().Info("run on-stop hooks")
        shutdownErrs := &ShutdownErrors{}
        for _, fn := range app.hooks.onStops {
            fn := fn
            if err := fn(ctx); err != nil {
                app.logger.ErrorContext(ctx, "on-stop hook error", "error", err)
                shutdownErrs.Add(err)
            }
        }

        // 记录总错误数
        if shutdownErrs.HasErrors() {
            app.logger.Error("shutdown completed with errors", "count", len(shutdownErrs.Errors()))
        }
    })

    return app.runG.Run()
}
```

---

## 6. CLI 优雅退出

### 文件: `cli.go`

**修改后:**
```go
package lynx

import (
    "context"
    "fmt"
    "os"
)

type SetupFunc func(ctx context.Context, app Lynx) error

type CLI struct {
    setup SetupFunc
    lynx  Lynx
}

func New(o *Options, setup SetupFunc) (*CLI, error) {
    app, err := newLynx(o)
    if err != nil {
        return nil, err
    }
    return &CLI{
        setup: setup,
        lynx:  app,
    }, nil
}

// Run executes the CLI application.
// On error, it prints the error to stderr and exits with code 1.
func (app *CLI) Run() {
    if err := app.RunE(); err != nil {
        fmt.Fprintf(os.Stderr, "Error: %v\n", err)
        os.Exit(1)
    }
}

// RunE executes the CLI application and returns any error.
func (app *CLI) RunE() error {
    if err := app.setup(app.lynx.Context(), app.lynx); err != nil {
        return err
    }
    return app.lynx.Run()
}
```

---

## 7. 健康检查增强

### 文件: `contrib/schedule/scheduler.go`

**修改后:**
```go
package schedule

import (
    "context"
    "errors"
    "log/slog"
    "sync/atomic"
    "time"

    "github.com/lynx-go/lynx"
    "github.com/lynx-go/x/log"
    "github.com/robfig/cron/v3"
)

type Scheduler struct {
    options       *Options
    tasks         []Task
    cron          *cron.Cron
    app           lynx.Lynx
    lastRunTime   atomic.Int64
    taskError     atomic.Pointer[error]
}

type Options struct {
    Cron              *cron.Cron
    Logger            *slog.Logger
    DebugEnabled      bool
    HealthCheckPeriod time.Duration // 如果设置，检查最近任务执行时间
}

type Option func(*Options)

func WithLogger(logger *slog.Logger) Option {
    return func(o *Options) { o.Logger = logger }
}

func WithCron(cron *cron.Cron) Option {
    return func(o *Options) { o.Cron = cron }
}

func WithDebugEnabled() Option {
    return func(o *Options) { o.DebugEnabled = true }
}

func WithHealthCheckPeriod(d time.Duration) Option {
    return func(o *Options) { o.HealthCheckPeriod = d }
}

func (s *Scheduler) CheckHealth() error {
    if s.cron == nil {
        return errors.New("scheduler not initialized")
    }

    // 检查是否有任务执行错误
    if errPtr := s.taskError.Load(); errPtr != nil && *errPtr != nil {
        return fmt.Errorf("scheduler has task error: %w", *errPtr)
    }

    // 如果配置了健康检查周期，检查最近任务执行时间
    if s.options.HealthCheckPeriod > 0 {
        lastRun := time.Unix(s.lastRunTime.Load(), 0)
        if time.Since(lastRun) > s.options.HealthCheckPeriod {
            return fmt.Errorf("no task executed in last %v", s.options.HealthCheckPeriod)
        }
    }

    return nil
}

// ... 其他方法保持不变 ...

func NewScheduler(tasks []Task, opts ...Option) (*Scheduler, error) {
    o := &Options{
        Logger: slog.Default(),
    }
    for _, opt := range opts {
        opt(o)
    }

    logger := NewSlogLogger(o.Logger, o.DebugEnabled)
    var cronInstance *cron.Cron
    if o.Cron != nil {
        cronInstance = o.Cron
    } else {
        cronInstance = cron.New(cron.WithSeconds(), cron.WithLogger(logger), cron.WithChain(cron.Recover(logger)))
    }

    scheduler := &Scheduler{options: o, cron: cronInstance, tasks: tasks}
    scheduler.lastRunTime.Store(time.Now().Unix()) // 初始化为当前时间

    for i := range tasks {
        task := tasks[i]
        if _, err := scheduler.cron.AddFunc(task.Cron(), func() {
            ctx := log.WithContext(context.Background(), "component", "scheduler", "task_name", task.Name())

            // 记录执行时间
            scheduler.lastRunTime.Store(time.Now().Unix())

            if err := task.HandlerFunc()(ctx); err != nil {
                log.ErrorContext(ctx, "schedule task execute error", err)
                // 存储最后一个错误
                scheduler.taskError.Store(&err)
            }
        }); err != nil {
            return nil, err
        }
    }

    return scheduler, nil
}
```

---

## 应用修复的步骤

1. **Phase 1** (紧急修复)
   - [ ] 修改 `lynx.go` 移除 Fatal 调用
   - [ ] 修改 `cli.go` 适配新的 newLynx 签名
   - [ ] 添加并发安全锁

2. **Phase 2** (短期修复)
   - [ ] 修改 Context 值获取函数
   - [ ] 修改 gRPC Server Stop 方法
   - [ ] 修改 CLI.Run 优雅退出

3. **Phase 3** (中期优化)
   - [ ] 添加错误聚合机制
   - [ ] 增强健康检查
   - [ ] 添加 Options 验证
