# 测试建议

当前代码库缺少单元测试，本文档提供测试规划建议。

---

## 测试优先级

### Phase 1: 核心功能测试 (必须)

这些测试验证框架的核心行为，优先级最高：

1. **生命周期测试** - `lynx_test.go`
2. **钩子系统测试** - `hooks_test.go`
3. **并发安全测试** - `lynx_test.go`

### Phase 2: 组件测试 (重要)

验证各组件的正确行为：

1. **HTTP 服务器测试** - `server/http/server_test.go`
2. **gRPC 服务器测试** - `server/grpc/server_test.go`
3. **调度器测试** - `contrib/schedule/scheduler_test.go`

### Phase 3: 集成测试 (推荐)

验证组件间的协作：

1. **端到端启动测试**
2. **优雅关闭测试**
3. **健康检查集成测试**

---

## 核心测试用例

### 1. 生命周期测试

```go
// lynx_test.go
package lynx

import (
    "context"
    "sync/atomic"
    "testing"
    "time"
)

// TestLynxNew 测试应用创建
func TestLynxNew(t *testing.T) {
    tests := []struct {
        name    string
        options *Options
        wantErr bool
    }{
        {
            name:    "default options",
            options: &Options{},
            wantErr: false,
        },
        {
            name: "with custom name",
            options: &Options{
                Name: "test-app",
            },
            wantErr: false,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            app, err := newLynx(tt.options)
            if (err != nil) != tt.wantErr {
                t.Errorf("newLynx() error = %v, wantErr %v", err, tt.wantErr)
                return
            }
            if !tt.wantErr && app == nil {
                t.Error("newLynx() returned nil app")
            }
        })
    }
}

// TestLynxContextValues 测试 Context 值传递
func TestLynxContextValues(t *testing.T) {
    app, err := newLynx(&Options{
        Name:    "test-app",
        ID:      "test-id",
        Version: "1.0.0",
    })
    if err != nil {
        t.Fatalf("newLynx() error = %v", err)
    }

    ctx := app.Context()

    if NameFromContext(ctx) != "test-app" {
        t.Errorf("NameFromContext() = %v, want %v", NameFromContext(ctx), "test-app")
    }
    if IDFromContext(ctx) != "test-id" {
        t.Errorf("IDFromContext() = %v, want %v", IDFromContext(ctx), "test-id")
    }
    if VersionFromContext(ctx) != "1.0.0" {
        t.Errorf("VersionFromContext() = %v, want %v", VersionFromContext(ctx), "1.0.0")
    }
}

// TestContextFromEmpty 测试空 Context 的安全处理
func TestContextFromEmpty(t *testing.T) {
    ctx := context.Background()

    // 这些调用不应 panic
    if NameFromContext(ctx) != "" {
        t.Errorf("NameFromContext(empty) = %v, want empty string", NameFromContext(ctx))
    }
    if IDFromContext(ctx) != "" {
        t.Errorf("IDFromContext(empty) = %v, want empty string", IDFromContext(ctx))
    }
    if VersionFromContext(ctx) != "" {
        t.Errorf("VersionFromContext(empty) = %v, want empty string", VersionFromContext(ctx))
    }
}

// TestLynxHooks 测试钩子注册
func TestLynxHooks(t *testing.T) {
    app, err := newLynx(&Options{Name: "test"})
    if err != nil {
        t.Fatalf("newLynx() error = %v", err)
    }

    var onStartCalled atomic.Bool
    var onStopCalled atomic.Bool

    err = app.Hooks(
        OnStart(func(ctx context.Context) error {
            onStartCalled.Store(true)
            return nil
        }),
        OnStop(func(ctx context.Context) error {
            onStopCalled.Store(true)
            return nil
        }),
    )
    if err != nil {
        t.Fatalf("Hooks() error = %v", err)
    }

    // 验证钩子被注册 (通过内部状态检查或其他方式)
    // 这需要暴露测试接口或使用反射
}
```

### 2. 并发安全测试

```go
// lynx_test.go

// TestHooksConcurrentAccess 测试并发 Hooks 调用
func TestHooksConcurrentAccess(t *testing.T) {
    app, err := newLynx(&Options{Name: "test"})
    if err != nil {
        t.Fatalf("newLynx() error = %v", err)
    }

    var wg sync.WaitGroup
    errors := make(chan error, 100)

    // 并发注册 hooks
    for i := 0; i < 50; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            err := app.Hooks(
                OnStart(func(ctx context.Context) error { return nil }),
                OnStop(func(ctx context.Context) error { return nil }),
            )
            if err != nil {
                errors <- err
            }
        }(i)
    }

    wg.Wait()
    close(errors)

    for err := range errors {
        t.Errorf("concurrent Hooks() error: %v", err)
    }
}

// TestHealthCheckersConcurrentAccess 测试并发添加组件
func TestHealthCheckersConcurrentAccess(t *testing.T) {
    app, err := newLynx(&Options{Name: "test"})
    if err != nil {
        t.Fatalf("newLynx() error = %v", err)
    }

    var wg sync.WaitGroup
    errors := make(chan error, 100)

    // 并发添加 mock 组件
    for i := 0; i < 20; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            err := app.Hooks(Components(&mockComponent{
                name: fmt.Sprintf("component-%d", id),
            }))
            if err != nil {
                errors <- err
            }
        }(i)
    }

    wg.Wait()
    close(errors)

    for err := range errors {
        t.Errorf("concurrent addComponents() error: %v", err)
    }
}

// mockComponent 用于测试
type mockComponent struct {
    name string
}

func (m *mockComponent) Name() string { return m.name }
func (m *mockComponent) Init(app Lynx) error { return nil }
func (m *mockComponent) Start(ctx context.Context) error {
    <-ctx.Done()
    return nil
}
func (m *mockComponent) Stop(ctx context.Context) {}
```

### 3. 组件测试

```go
// server/http/server_test.go
package http

import (
    "context"
    "net/http"
    "net/http/httptest"
    "testing"
    "time"
)

func TestNewServer(t *testing.T) {
    handler := http.NewServeMux()
    handler.HandleFunc("/test", func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
    })

    server := NewServer(handler, WithAddr(":0")) // 使用随机端口

    if server.Name() != "http" {
        t.Errorf("Server.Name() = %v, want %v", server.Name(), "http")
    }
}

func TestServerStartStop(t *testing.T) {
    handler := http.NewServeMux()
    handler.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
    })

    server := NewServer(handler, WithAddr(":0"))

    // 初始化
    if err := server.Init(nil); err != nil {
        t.Fatalf("Init() error = %v", err)
    }

    // 启动 (在 goroutine 中)
    ctx, cancel := context.WithCancel(context.Background())
    done := make(chan error, 1)
    go func() {
        done <- server.Start(ctx)
    }()

    // 等待一小段时间让服务器启动
    time.Sleep(100 * time.Millisecond)

    // 停止
    stopCtx, stopCancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer stopCancel()
    server.Stop(stopCtx)

    cancel()

    // 等待启动 goroutine 结束
    select {
    case err := <-done:
        if err != nil && err != http.ErrServerClosed {
            t.Errorf("Start() error = %v", err)
        }
    case <-time.After(5 * time.Second):
        t.Error("Start() did not return in time")
    }
}

// gRPC 服务器测试
// server/grpc/server_test.go
package grpc

import (
    "context"
    "testing"
    "time"

    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials/insecure"
)

func TestNewServer(t *testing.T) {
    server := NewServer(WithAddr(":0"))

    if server.Name() != "grpc" {
        t.Errorf("Server.Name() = %v, want %v", server.Name(), "grpc")
    }
}

func TestGRPCServerHealthCheck(t *testing.T) {
    server := NewServer(WithAddr(":0"))

    // 初始状态应该不健康
    if err := server.CheckHealth(); err == nil {
        t.Error("CheckHealth() should return error before Start()")
    }

    // 模拟启动
    ctx := context.Background()
    if err := server.Init(nil); err != nil {
        t.Fatalf("Init() error = %v", err)
    }

    done := make(chan error, 1)
    go func() {
        done <- server.Start(ctx)
    }()

    time.Sleep(100 * time.Millisecond)

    // 启动后应该健康
    if err := server.CheckHealth(); err != nil {
        t.Errorf("CheckHealth() after Start() error = %v", err)
    }

    // 停止
    stopCtx, _ := context.WithTimeout(context.Background(), 5*time.Second)
    server.Stop(stopCtx)

    // 停止后应该不健康
    if err := server.CheckHealth(); err == nil {
        t.Error("CheckHealth() should return error after Stop()")
    }
}

func TestGRPCServerGracefulStop(t *testing.T) {
    server := NewServer(WithAddr(":0"))
    server.Init(nil)

    ctx := context.Background()
    done := make(chan error, 1)
    go func() {
        done <- server.Start(ctx)
    }()

    time.Sleep(100 * time.Millisecond)

    // 测试带超时的停止
    stopCtx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()

    stopDone := make(chan struct{})
    go func() {
        defer close(stopDone)
        server.Stop(stopCtx)
    }()

    select {
    case <-stopDone:
        // 正常
    case <-time.After(3 * time.Second):
        t.Error("Stop() did not complete in time")
    }
}
```

### 4. 调度器测试

```go
// contrib/schedule/scheduler_test.go
package schedule

import (
    "context"
    "sync/atomic"
    "testing"
    "time"
)

func TestSchedulerCheckHealth(t *testing.T) {
    tasks := []Task{}

    scheduler, err := NewScheduler(tasks)
    if err != nil {
        t.Fatalf("NewScheduler() error = %v", err)
    }

    // 未启动时应该返回 nil (当前实现)
    if err := scheduler.CheckHealth(); err != nil {
        t.Errorf("CheckHealth() before Init() error = %v", err)
    }
}

func TestSchedulerTaskExecution(t *testing.T) {
    var executed atomic.Int32

    task := &mockTask{
        name: "test-task",
        cron: "* * * * * *", // 每秒执行
        handler: func(ctx context.Context) error {
            executed.Add(1)
            return nil
        },
    }

    scheduler, err := NewScheduler([]Task{task})
    if err != nil {
        t.Fatalf("NewScheduler() error = %v", err)
    }

    if err := scheduler.Init(nil); err != nil {
        t.Fatalf("Init() error = %v", err)
    }

    // 启动
    ctx, cancel := context.WithCancel(context.Background())
    done := make(chan error, 1)
    go func() {
        done <- scheduler.Start(ctx)
    }()

    // 等待任务执行
    time.Sleep(2 * time.Second)

    // 停止
    scheduler.Stop(context.Background())
    cancel()

    if executed.Load() == 0 {
        t.Error("task was not executed")
    }
}

type mockTask struct {
    name    string
    cron    string
    handler HandlerFunc
}

func (m *mockTask) Name() string         { return m.name }
func (m *mockTask) Cron() string         { return m.cron }
func (m *mockTask) HandlerFunc() HandlerFunc { return m.handler }
```

### 5. 表格驱动测试示例

```go
// options_test.go
package lynx

import (
    "testing"
    "time"
)

func TestOptionsEnsureDefaults(t *testing.T) {
    tests := []struct {
        name     string
        input    Options
        expected Options
    }{
        {
            name:     "empty options",
            input:    Options{},
            expected: Options{Name: "lynx", CloseTimeout: 30 * time.Second},
        },
        {
            name:     "custom name",
            input:    Options{Name: "custom"},
            expected: Options{Name: "custom", CloseTimeout: 30 * time.Second},
        },
        {
            name:     "custom timeout",
            input:    Options{CloseTimeout: 10 * time.Second},
            expected: Options{Name: "lynx", CloseTimeout: 10 * time.Second},
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            opts := tt.input
            opts.EnsureDefaults()

            if opts.Name != tt.expected.Name {
                t.Errorf("Name = %v, want %v", opts.Name, tt.expected.Name)
            }
            if opts.CloseTimeout != tt.expected.CloseTimeout {
                t.Errorf("CloseTimeout = %v, want %v", opts.CloseTimeout, tt.expected.CloseTimeout)
            }
        })
    }
}
```

---

## 测试工具和辅助函数

```go
// testing_helper.go
package lynx

import (
    "context"
    "testing"
    "time"
)

// TestApp 创建用于测试的应用实例
func TestApp(tb testing.TB, opts ...Option) Lynx {
    defaultOpts := &Options{
        Name:         "test-app",
        ID:           "test-id",
        Version:      "0.0.0-test",
        CloseTimeout: 5 * time.Second,
    }

    for _, opt := range opts {
        opt(defaultOpts)
    }

    app, err := newLynx(defaultOpts)
    if err != nil {
        tb.Fatalf("TestApp() error = %v", err)
    }

    tb.Cleanup(func() {
        app.Close()
    })

    return app
}

// WaitForCondition 等待条件满足或超时
func WaitForCondition(t *testing.T, condition func() bool, timeout time.Duration, msg string) {
    t.Helper()
    deadline := time.Now().Add(timeout)
    for time.Now().Before(deadline) {
        if condition() {
            return
        }
        time.Sleep(10 * time.Millisecond)
    }
    t.Fatalf("condition not met within %v: %s", timeout, msg)
}
```

---

## 测试覆盖率目标

| 模块 | 目标覆盖率 | 优先级 |
|------|-----------|--------|
| `lynx.go` | 80% | 高 |
| `hooks.go` | 90% | 高 |
| `component.go` | 70% | 中 |
| `server/http/` | 75% | 中 |
| `server/grpc/` | 75% | 中 |
| `contrib/schedule/` | 70% | 低 |
| `command.go` | 80% | 中 |
| `cli.go` | 90% | 高 |

---

## 运行测试

```bash
# 运行所有测试
go test ./...

# 运行带覆盖率的测试
go test -cover ./...

# 生成覆盖率报告
go test -coverprofile=coverage.out ./...
go tool cover -html=coverage.out

# 运行竞态检测
go test -race ./...

# 运行特定测试
go test -run TestLynxNew ./...

# 运行基准测试
go test -bench=. ./...
```

---

## 基准测试建议

```go
// lynx_bench_test.go
package lynx

import (
    "context"
    "testing"
)

func BenchmarkHooks(b *testing.B) {
    app, _ := newLynx(&Options{Name: "bench"})

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        app.Hooks(OnStart(func(ctx context.Context) error { return nil }))
    }
}

func BenchmarkContextValues(b *testing.B) {
    app, _ := newLynx(&Options{Name: "bench", ID: "bench-id", Version: "1.0.0"})
    ctx := app.Context()

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        NameFromContext(ctx)
        IDFromContext(ctx)
        VersionFromContext(ctx)
    }
}
```
